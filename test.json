{"1862140487967379456": {"1862140591449247801": {"problem_set_problem_id": "1862140591449247801", "compiler": "GCC", "program_content": "\nint GetHeight(BinTree BT) {\n    if (!BT) {\n        return 0;\n    }\n    int l = GetHeight(BT->Left), r = GetHeight(BT->Right);\n    return (l < r ? r : l) + 1;\n}\n", "problem_type": "CODE_COMPLETION", "title": "求二叉树高度"}, "1862140591449247802": {"problem_set_problem_id": "1862140591449247802", "compiler": "GCC", "program_content": "\nvoid PreorderPrintLeaves(BinTree BT) {\n    if (!BT)\n        return;\n\n    if (!BT->Left && !BT->Right)\n        printf(\" %c\", BT->Data);\n    PreorderPrintLeaves(BT->Left);\n    PreorderPrintLeaves(BT->Right);\n}\n", "problem_type": "CODE_COMPLETION", "title": "先序输出叶结点"}, "1862140591449247803": {"problem_set_problem_id": "1862140591449247803", "compiler": "GCC", "program_content": "\nvoid InorderTraversal(BinTree BT) {\n    if (!BT)\n        return;\n    InorderTraversal(BT->Left);\n    printf(\" %c\", BT->Data);\n    InorderTraversal(BT->Right);\n}\nvoid PreorderTraversal(BinTree BT) {\n    if (!BT)\n        return;\n    printf(\" %c\", BT->Data);\n    PreorderTraversal(BT->Left);\n    PreorderTraversal(BT->Right);\n}\nvoid PostorderTraversal(BinTree BT) {\n    if (!BT)\n        return;\n    PostorderTraversal(BT->Left);\n    PostorderTraversal(BT->Right);\n    printf(\" %c\", BT->Data);\n}\nvoid LevelorderTraversal(BinTree BT) {\n    BinTree q[200];\n    int l = 0, r = 0;\n    q[r++] = BT;\n    while (l != r && q[l]) {\n        q[r] = NULL;\n        BT = q[l++];\n        printf(\" %c\", BT->Data);\n        if (BT->Left)\n            q[r++] = BT->Left;\n        if (BT->Right)\n            q[r++] = BT->Right;\n    }\n}\n", "problem_type": "CODE_COMPLETION", "title": "二叉树的遍历"}, "1862140591449247804": {"problem_set_problem_id": "1862140591449247804", "compiler": "GCC", "program_content": "int NodeCount(BiTree T) {\n    if (!T)\n        return 0;\n\n    return NodeCount(T->lchild) + NodeCount(T->rchild) + 1;\n}\n", "problem_type": "CODE_COMPLETION", "title": "统计二叉树结点个数"}, "1862140591449247805": {"problem_set_problem_id": "1862140591449247805", "compiler": "GCC", "program_content": "int NodeCount(BiTree T) {\n    if (!T)\n        return 0;\n\n    return NodeCount(T->lchild) + NodeCount(T->rchild) + (!T->lchild +\n                                                          !T->rchild == 1);\n}\n", "problem_type": "CODE_COMPLETION", "title": "统计二叉树度为1的结点个数"}, "1862140591449247806": {"problem_set_problem_id": "1862140591449247806", "compiler": "GCC", "program_content": "int LeafCount(BiTree T) {\n    if (!T)\n        return 0;\n    if (!T->lchild && !T->rchild)\n        return 1;\n    return LeafCount(T->lchild) + LeafCount(T->rchild);\n}\n", "problem_type": "CODE_COMPLETION", "title": "统计二叉树叶子结点个数"}, "1862140591449247807": {"problem_set_problem_id": "1862140591449247807", "compiler": "GCC", "program_content": "#include    <stdio.h>\n\nvoid my_scanf(int *a, int *b) {\n    int c;\n    while ((c = getc(stdin)) == ' ' || c == '\\n') ;\n    *a = c;\n    while ((c = getc(stdin)) == ' ' || c == '\\n') ;\n    *b = c;\n}\n\nvoid do_print_leaf(int A[][3], int bi) {\n    int q[200], q_len = 0;\n    int l = 0, r = 0, i;\n\n    q[r++] = bi;\n\n    while (l != r && q[l] != -1) {\n        q[r] = -1;\n        i = q[l++];\n        if (A[i][0] == -1 && A[i][1] == -1)\n            printf(\"%d%s\", i, q[l] == -1 ? \"\" : \" \");\n        if (A[i][0] != -1)\n            q[r++] = A[i][0];\n        if (A[i][1] != -1)\n            q[r++] = A[i][1];\n    }\n}\n\nint A[10][3];\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; ++i) {\n        A[i][2] = -1;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        my_scanf(&A[i][0], &A[i][1]);\n        A[i][0] = A[i][0] != '-' ? A[i][0] - '0' : -1;\n        A[i][1] = A[i][1] != '-' ? A[i][1] - '0' : -1;\n        if (A[i][0] != -1) {\n            A[A[i][0]][2] = i;\n        }\n        if (A[i][1] != -1) {\n            A[A[i][1]][2] = i;\n        }\n    }\n\n    int root_i;\n\n    for (int i = 0; i < n; ++i) {\n        if (A[i][2] == -1)\n            root_i = i;\n    }\n\n    do_print_leaf(A, root_i);\n\n    return 0;\n}\n", "problem_type": "PROGRAMMING", "title": "列出叶结点"}, "1862140591449247808": {"problem_set_problem_id": "1862140591449247808", "compiler": "GCC", "program_content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// const int N = 100 + 5;\n\ntypedef struct node {\n    char data;\n    struct node *lchild, *rchild;\n} BNode, *BTree;\n\nvoid visit(BTree);\nvoid preOrder(BTree);\nvoid inOrder(BTree);\nvoid postOrder(BTree);\nBTree createTreePreIn(char *, char *, int);\n\nint getHeight(BTree);\nint getLeafCnt(BTree);\nint getNodeCnt(BTree);\n\nvoid visit(BTree T) {\n    printf(\"%c\", T->data);\n}\n\nvoid preOrder(BTree T) {\n    if (!T)\n        return;\n    visit(T);\n    preOrder(T->lchild);\n    preOrder(T->rchild);\n}\n\nvoid inOrder(BTree T) {\n    if (!T)\n        return;\n    inOrder(T->lchild);\n    visit(T);\n    inOrder(T->rchild);\n}\nvoid postOrder(BTree T) {\n    if (!T)\n        return;\n    postOrder(T->lchild);\n    postOrder(T->rchild);\n    visit(T);\n}\n\nBTree createTreePreIn(char *pre, char *in, int len) {\n    if (len == 0)\n        return NULL;\n\n    BTree T = (BTree) malloc(sizeof(BNode));\n\n    T->data = pre[0];\n\n    int n = 1;\n\n    for (int i = 0; i < len; ++i) {\n        if (in[i] == pre[0])\n            n = i;\n    }\n\n    T->lchild = createTreePreIn(pre + 1, in, n);\n    T->rchild = createTreePreIn(pre + 1 + n, in + n + 1, len - 1 - n);\n\n    return T;\n}\n\nBTree createTreeInPost(char *in, char *post, int len) {\n    if (len == 0)\n        return NULL;\n\n    BTree T = (BTree) malloc(sizeof(BNode));\n\n    T->data = post[len - 1];\n\n    int n = len;\n\n    for (int i = len - 1; i >= 0; --i) {\n        if (in[i] == post[len - 1])\n            n = i;\n    }\n\n    T->lchild = createTreeInPost(in, post, n);\n    T->rchild = createTreeInPost(in + n + 1, post + n, len - n - 1);\n\n    return T;\n}\n\nint getHeight(BTree T) {\n    if (!T)\n        return 0;\n\n    int lt = getHeight(T->lchild);\n    int rt = getHeight(T->rchild);\n\n    int n = lt;\n    if (rt > n)\n        n = rt;\n\n    return n + 1;\n}\n\nint getLeafCnt(BTree T) {\n    if (!T)\n        return 0;\n    if (!T->lchild && !T->rchild)\n        return 1;\n    return getLeafCnt(T->lchild) + getLeafCnt(T->rchild);\n}\n\nint getNodeCnt(BTree T) {\n    if (!T)\n        return 0;\n\n    return getNodeCnt(T->lchild) + getNodeCnt(T->rchild) + 1;\n}\n\n#define N 100\nint main() {\n\n    //char pre[N] = \"1245367\", in[N] = \"4251637\", post[N] = \"4526731\";\n    char pre[N], in[N], post[N];\n\n    //for (int i = 0; i < 3; i++) {\n    //\n    bzero(pre, sizeof(pre));\n    bzero(in, sizeof(in));\n    bzero(post, sizeof(post));\n\n    int len;\n    scanf(\"%d %s %s\", &len, pre, in);\n    BTree T = createTreePreIn(pre, in, len);\n    printf(\"%d\\n\", getHeight(T));\n\n    return 0;\n}\n", "problem_type": "PROGRAMMING", "title": "还原二叉树"}, "1862140591449247809": {"problem_set_problem_id": "1862140591449247809", "compiler": "GCC", "program_content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// const int N = 100 + 5;\n\ntypedef struct node {\n    int data;\n    struct node *lchild, *rchild;\n} BNode, *BTree;\n\nvoid visit(BTree);\nvoid preOrder(BTree);\nvoid inOrder(BTree);\nvoid postOrder(BTree);\nBTree createTreePreIn(int *, int *, int);\n\nint getHeight(BTree);\nint getLeafCnt(BTree);\nint getNodeCnt(BTree);\n\nvoid visit(BTree T) {\n    printf(\"%d\", T->data);\n}\n\nvoid preOrder(BTree T) {\n    if (!T)\n        return;\n    visit(T);\n    preOrder(T->lchild);\n    preOrder(T->rchild);\n}\n\nvoid inOrder(BTree T) {\n    if (!T)\n        return;\n    inOrder(T->lchild);\n    visit(T);\n    inOrder(T->rchild);\n}\nvoid postOrder(BTree T) {\n    if (!T)\n        return;\n    postOrder(T->lchild);\n    postOrder(T->rchild);\n    visit(T);\n}\n\nBTree createTreePreIn(int *pre, int *in, int len) {\n    if (len == 0)\n        return NULL;\n\n    BTree T = (BTree) malloc(sizeof(BNode));\n\n    T->data = pre[0];\n\n    int n = 1;\n\n    for (int i = 0; i < len; ++i) {\n        if (in[i] == pre[0])\n            n = i;\n    }\n\n    T->lchild = createTreePreIn(pre + 1, in, n);\n    T->rchild = createTreePreIn(pre + 1 + n, in + n + 1, len - 1 - n);\n\n    return T;\n}\n\nint getHeight(BTree T) {\n    if (!T)\n        return 0;\n\n    int lt = getHeight(T->lchild);\n    int rt = getHeight(T->rchild);\n\n    int n = lt;\n    if (rt > n)\n        n = rt;\n\n    return n + 1;\n}\n\nint getLeafCnt(BTree T) {\n    if (!T)\n        return 0;\n    if (!T->lchild && !T->rchild)\n        return 1;\n    return getLeafCnt(T->lchild) + getLeafCnt(T->rchild);\n}\n\nint getNodeCnt(BTree T) {\n    if (!T)\n        return 0;\n\n    return getNodeCnt(T->lchild) + getNodeCnt(T->rchild) + 1;\n}\n\nvoid exchange(BTree T) {\n    if (!T)\n        return;\n\n    BTree _ = T->lchild;\n    T->lchild = T->rchild;\n    T->rchild = _;\n    exchange(T->lchild);\n    exchange(T->rchild);\n}\n\nvoid LevelorderTraversal(BTree BT) {\n    BTree q[200];\n    int l = 0, r = 0;\n    q[r++] = BT;\n    while (l != r && q[l]) {\n        q[r] = NULL;\n        BT = q[l++];\n        printf(\"%d\", BT->data);\n        if (BT->lchild)\n            q[r++] = BT->lchild;\n        if (BT->rchild)\n            q[r++] = BT->rchild;\n        if (q[l])\n            printf(\" \");\n    }\n}\n\n#define N 100\nint main() {\n\n    //char pre[N] = \"1245367\", in[N] = \"4251637\", post[N] = \"4526731\";\n    int pre[N], in[N], post[N];\n\n    //for (int i = 0; i < 3; i++) {\n    //\n    bzero(pre, sizeof(pre));\n    bzero(in, sizeof(in));\n    bzero(post, sizeof(post));\n\n    int len;\n    scanf(\"%d\", &len);\n    for (int i = 0; i < len; ++i)\n        scanf(\"%d\", in + i);\n    for (int i = 0; i < len; ++i)\n        scanf(\"%d\", pre + i);\n    BTree T = createTreePreIn(pre, in, len);\n\n    exchange(T);\n\n    LevelorderTraversal(T);\n\n    return 0;\n}\n", "problem_type": "PROGRAMMING", "title": "玩转二叉树"}}}