{"1854547178661408768": {"1854547412460302350": {"problem_set_problem_id": "1854547412460302350", "compiler": "GCC", "program_content": "int\npush(SqStack *s, ElemType item)\n{\n\tif (isFull(*s))\n\t\treturn 0;\n\ts->top++;\n\ts->data[s->top] = item;\n\treturn 1;\n}\n", "problem_type": "CODE_COMPLETION", "title": "入栈操作"}, "1854547412460302351": {"problem_set_problem_id": "1854547412460302351", "compiler": "GCC", "program_content": "bool\nPush(Stack s, ElementType x)\n{\n\tif (s->Top == s->MaxSize) {\n\t\tprintf(\"Stack Full\\n\");\n\t\treturn false;\n\t}\n\n\ts->Data[s->Top] = x;\n\ts->Top++;\n\n\treturn true;\n}\n\nElementType\nPop(Stack s)\n{\n\tif (s->Top == 0) {\n\t\tprintf(\"Stack Empty\\n\");\n\t\treturn ERROR;\n\t}\n\n\ts->Top--;\n\treturn s->Data[s->Top];\n}\n", "problem_type": "CODE_COMPLETION", "title": "另类堆栈"}, "1854547412460302352": {"problem_set_problem_id": "1854547412460302352", "compiler": "GCC", "program_content": "int\nDecimalConvert(SqStack *s, int dec, int scale)\n{\n\tif (scale != 2 && scale != 8 && scale != 16)\n\t\treturn 0;\n\twhile (dec > 0) {\n\t\tif (!SqStackPush(s, dec % scale))\n\t\t\treturn 0;\n\t\tdec /= scale;\n\t}\n\treturn 1;\n}\n", "problem_type": "CODE_COMPLETION", "title": "用顺序栈实现将非负的十进制数转换为指定的进制数【有题解视频，可本地编译器调试】"}, "1854547412460302353": {"problem_set_problem_id": "1854547412460302353", "compiler": "GCC", "program_content": "bool\nAddQ(Queue q, ElementType x)\n{\n\tif (q->Count == q->MaxSize) {\n\t\tprintf(\"Queue Full\\n\");\n\t\treturn false;\n\t}\n\n\tq->Data[(q->Front + q->Count) % q->MaxSize] = x;\n\tq->Count++;\n\treturn true;\n}\n\nElementType\nDeleteQ(Queue q)\n{\n\tif (q->Count == 0) {\n\t\tprintf(\"Queue Empty\\n\");\n\t\treturn ERROR;\n\t}\n\n\tq->Count--;\n\tint ret = q->Data[q->Front];\n\tq->Front = (q->Front + 1) % q->MaxSize;\n\treturn ret;\n}\n", "problem_type": "CODE_COMPLETION", "title": "另类循环队列"}, "1854547412460302354": {"problem_set_problem_id": "1854547412460302354", "compiler": "GCC", "program_content": "Status\nQueueInsert(LinkQueue *q, ElemType e)\n{\n\tLinkList p = (LinkList) malloc(sizeof (LNode));\n\tp->data = e;\n\tq->rear->next = p;\n\tq->rear = p;\n\treturn OK;\n}\n\nStatus\nQueueDelete(LinkQueue *q, ElemType *e)\n{\n\tif (!q->front->next)\n\t\treturn ERROR;\n\tLinkList p = q->front->next;\n\t*e = p->data;\n\tq->front->next = p->next;\n\tfree(p);\n\treturn OK;\n}\n", "problem_type": "CODE_COMPLETION", "title": "带头结点的链队列的基本操作"}, "1854547412460302355": {"problem_set_problem_id": "1854547412460302355", "compiler": "GXX", "program_content": "#include <stdio.h>\n#include <string.h>\n#define M (1000 + 5)\n\ntypedef int ElemType;\n\ntypedef struct {\n\tElemType data[M];\n\tint top;\n} SqStack, *SqStackP;\n\nvoid init(SqStackP);\nint isEmpty(const SqStackP);\nint isFull(const SqStackP);\nint push(SqStackP, const ElemType);\nint pop(SqStackP, ElemType *);\nint getTop(const SqStackP, ElemType *);\nint\ntest_2()\n{\n\tSqStack s;\n\tchar ss[101];\n\tElemType x;\n\tinit(&s);\n\twhile (scanf(\"%s\", ss + strlen(ss)) != EOF) ;\n\tint matched = 1;\n\tfor (int i = 0; i < strlen(ss); ++i) {\n\t\tif (ss[i] == '{' || ss[i] == '[' || ss[i] == '(') {\n\t\t\tpush(&s, ss[i]);\n\t\t} else if (ss[i] == '}' || ss[i] == ']' || ss[i] == ')') {\n\t\t\tif (isEmpty(&s) || ss[i] == '}' && s.data[s.top] != '{'\n\t\t\t    || ss[i] == ']' && s.data[s.top] != '['\n\t\t\t    || ss[i] == ')' && s.data[s.top] != '(') {\n\t\t\t\tmatched = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ts.top--;\n\t\t\t}\n\t\t}\n\t}\n\tif (isEmpty(&s) && matched)\n\t\tprintf(\"yes\\n\");\n\telse\n\t\tprintf(\"no\\n\");\n\treturn 0;\n}\n\nint\nmain()\n{\n\ttest_2();\n\treturn 0;\n}\n\nvoid\ninit(SqStackP s)\n{\n\ts->top = -1;\n}\n\nint\nisEmpty(const SqStackP s)\n{\n\treturn s->top == -1;\n}\n\nint\nisFull(const SqStackP s)\n{\n\treturn s->top == M - 1;\n}\n\nint\npush(SqStackP s, ElemType item)\n{\n\tif (isFull(s))\n\t\treturn 0;\n\n\ts->top += 1;\n\ts->data[s->top] = item;\n\treturn 1;\n}\n\nint\npop(SqStackP s, ElemType *item)\n{\n\tif (isEmpty(s))\n\t\treturn 0;\n\n\t*item = s->data[s->top];\n\ts->top -= 1;\n\n\treturn 1;\n}\n\nint\ngetTop(const SqStackP s, ElemType *item)\n{\n\tif (isEmpty(s))\n\t\treturn 0;\n\n\t*item = s->data[s->top];\n\treturn 1;\n}\n", "problem_type": "PROGRAMMING", "title": "括号匹配"}, "1854547412460302356": {"problem_set_problem_id": "1854547412460302356", "compiler": "GXX", "program_content": "#include <stdio.h>\n#include <string.h>\n#define M (1000 + 5)\n\ntypedef int ElemType;\n\ntypedef struct {\n\tElemType data[M];\n\tint top;\n\tint max_size;\n} SqStack, *SqStackP;\n\nvoid init(SqStackP, int);\nint isEmpty(const SqStackP);\nint isFull(const SqStackP);\nint push(SqStackP, const ElemType);\nint pop(SqStackP, ElemType *);\nint getTop(const SqStackP, ElemType *);\nvoid\ntest_2()\n{\n\tSqStack s;\n\tchar ss[101];\n\tint m;\n\tscanf(\"%d\", &m);\n\tElemType x;\n\tinit(&s, m);\n\tscanf(\"%s\", ss);\n\tint ok = 1;\n\tfor (int i = 0; i < strlen(ss); i++) {\n\t\tswitch (ss[i]) {\n\t\tcase 'X':\n\t\t\tif (!pop(&s, &x)) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tif (!push(&s, 1)) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ok && isEmpty(&s))\n\t\tprintf(\"YES\\n\");\n\telse\n\t\tprintf(\"NO\\n\");\n}\n\nint\nmain()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--)\n\t\ttest_2();\n\treturn 0;\n}\n\nvoid\ninit(SqStackP s, int max_size)\n{\n\ts->max_size = max_size;\n\ts->top = -1;\n}\n\nint\nisEmpty(const SqStackP s)\n{\n\treturn s->top == -1;\n}\n\nint\nisFull(const SqStackP s)\n{\n\treturn s->top == s->max_size - 1;\n}\n\nint\npush(SqStackP s, ElemType item)\n{\n\tif (isFull(s))\n\t\treturn 0;\n\n\ts->top += 1;\n\ts->data[s->top] = item;\n\treturn 1;\n}\n\nint\npop(SqStackP s, ElemType *item)\n{\n\tif (isEmpty(s))\n\t\treturn 0;\n\n\t*item = s->data[s->top];\n\ts->top -= 1;\n\n\treturn 1;\n}\n\nint\ngetTop(const SqStackP s, ElemType *item)\n{\n\tif (isEmpty(s))\n\t\treturn 0;\n\n\t*item = s->data[s->top];\n\treturn 1;\n}\n", "problem_type": "PROGRAMMING", "title": "栈操作的合法性"}, "1854547412460302357": {"problem_set_problem_id": "1854547412460302357", "compiler": "GCC", "program_content": "#include <stdio.h>\n#include <string.h>\n#define M (1000 + 5)\n\ntypedef float ElemType;\n\ntypedef struct {\n\tElemType data[M];\n\tint top;\n} SqStack, *SqStackP;\n\nvoid init(SqStackP);\nint isEmpty(const SqStackP);\nint isFull(const SqStackP);\nint push(SqStackP, const ElemType);\nint pop(SqStackP, ElemType *);\nint getTop(const SqStackP, ElemType *);\nint\ntest_3()\n{\n\tSqStack s;\n\tElemType x = 0, a, b, cnt = 0;\n\tchar ss[21];\n\tinit(&s);\n\twhile (scanf(\"%s\", ss) != EOF) {\n\t\tinit(&s);\n\t\tfor (int i = 0; i < strlen(ss); ++i) {\n\t\t\tchar c = ss[i];\n\t\t\tif ('0' <= c && c <= '9') {\n\t\t\t\tpush(&s, c - '0');\n\t\t\t} else {\n\t\t\t\tpop(&s, &b);\n\t\t\t\tpop(&s, &a);\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '+':\n\t\t\t\t\ta += b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\ta -= b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\ta *= b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\ta /= b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpush(&s, a);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.02f\\n\", s.data[s.top]);\n\t}\n\treturn 0;\n}\n\nint\nmain()\n{\n\t// test_1();\n\t// test_2();\n\ttest_3();\n\treturn 0;\n}\n\nvoid\ninit(SqStackP s)\n{\n\ts->top = -1;\n}\n\nint\nisEmpty(const SqStackP s)\n{\n\treturn s->top == -1;\n}\n\nint\nisFull(const SqStackP s)\n{\n\treturn s->top == M - 1;\n}\n\nint\npush(SqStackP s, ElemType item)\n{\n\tif (isFull(s))\n\t\treturn 0;\n\n\ts->top += 1;\n\ts->data[s->top] = item;\n\treturn 1;\n}\n\nint\npop(SqStackP s, ElemType *item)\n{\n\tif (isEmpty(s))\n\t\treturn 0;\n\n\t*item = s->data[s->top];\n\ts->top -= 1;\n\n\treturn 1;\n}\n\nint\ngetTop(const SqStackP s, ElemType *item)\n{\n\tif (isEmpty(s))\n\t\treturn 0;\n\n\t*item = s->data[s->top];\n\treturn 1;\n}\n", "problem_type": "PROGRAMMING", "title": "表达式求值"}, "1854547412460302358": {"problem_set_problem_id": "1854547412460302358", "compiler": "GCC", "program_content": "#include <stdio.h>\n\n#define M (10)\n\ntypedef int ElemType;\n\ntypedef struct {\n\tElemType data[M];\n\tint front, rear;\n} SqCyQueue, *SqCyQueueP;\n\nvoid init(SqCyQueueP);\nint isEmpty(SqCyQueueP);\nint isFull(SqCyQueueP);\nint push(SqCyQueueP, ElemType);\nint pop(SqCyQueueP, ElemType *);\nint popIndex(SqCyQueueP, int, ElemType *);\nint getFront(SqCyQueueP, ElemType *);\nint getSize(SqCyQueueP);\n\nint\nmain()\n{\n\tint n, k, m, idx = 0;\n\tSqCyQueue queue, queue_out;\n\tscanf(\"%d\", &n);\n\tinit(&queue);\n\tinit(&queue_out);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 0) {\n\t\t\tif (pop(&queue, &m)) {\n\t\t\t\tprintf(\"%d \", m);\n\t\t\t} else {\n\t\t\t\tprintf(\"EMPTY \");\n\t\t\t}\n\t\t} else {\n\t\t\tif (!push(&queue, k)) {\n\t\t\t\tprintf(\"FULL \");\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\twhile (!isEmpty(&queue)) {\n\t\tpop(&queue, &m);\n\t\tprintf(\"%d \", m);\n\t}\n\treturn 0;\n}\n\nvoid\ninit(SqCyQueueP q)\n{\n\tq->front = q->rear = 0;\n}\n\nint\nisEmpty(SqCyQueueP q)\n{\n\treturn q->front == q->rear;\n}\n\nint\nisFull(SqCyQueueP q)\n{\n\treturn (q->rear + 1) % M == q->front;\n}\n\nint\npush(SqCyQueueP q, ElemType item)\n{\n\tif (isFull(q)) {\n\t\treturn 0;\n\t}\n\n\tq->data[q->rear] = item;\n\tq->rear = (q->rear + 1) % M;\n\n\treturn 1;\n}\n\nint\npop(SqCyQueueP q, ElemType *item)\n{\n\tif (isEmpty(q)) {\n\t\treturn 0;\n\t}\n\n\t*item = q->data[q->front];\n\tq->front = (q->front + 1) % M;\n\n\treturn 1;\n}\n\nint\ngetFront(SqCyQueueP q, ElemType *item)\n{\n\tif (isEmpty(q)) {\n\t\tprintf(\"队列已空！\\n\");\n\t\treturn 0;\n\t}\n\t*item = q->data[q->rear];\n\treturn 1;\n}\n\nint\ngetSize(SqCyQueueP q)\n{\n\treturn (M + q->rear - q->front) % M;\n}\n", "problem_type": "PROGRAMMING", "title": "队的基本操作"}, "1854547412460302359": {"problem_set_problem_id": "1854547412460302359", "compiler": "GCC", "program_content": "#include <stdio.h>\n\n#define M (1005)\n\ntypedef int ElemType;\n\ntypedef struct {\n\tElemType data[M];\n\tint front, rear;\n} SqCyQueue, *SqCyQueueP;\n\nvoid init(SqCyQueueP);\nint isEmpty(SqCyQueueP);\nint isFull(SqCyQueueP);\nint push(SqCyQueueP, ElemType);\nint pop(SqCyQueueP, ElemType *);\nint popIndex(SqCyQueueP, int, ElemType *);\nint getFront(SqCyQueueP, ElemType *);\nint getSize(SqCyQueueP);\n\nint\nmain()\n{\n\tint n, k, m, idx = 0;\n\tSqCyQueue queue, queue_out;\n\tscanf(\"%d\", &n);\n\tinit(&queue);\n\tinit(&queue_out);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &k);\n\t\tif (k % 2 == 1)\n\t\t\tpush(&queue, k);\n\t\telse\n\t\t\tpush(&queue_out, k);\n\t}\n\tint c = 1;\n\twhile (!isEmpty(&queue) || !isEmpty(&queue_out)) {\n\t\tif (!isEmpty(&queue)) {\n\t\t\tpop(&queue, &m);\n\t\t\tidx++;\n\t\t\tprintf(\"%d%s\", m, idx == n ? \"\" : \" \");\n\t\t}\n\t\tif (!isEmpty(&queue_out) && c % 2 == 0) {\n\t\t\tpop(&queue_out, &m);\n\t\t\tidx++;\n\t\t\tprintf(\"%d%s\", m, idx == n ? \"\" : \" \");\n\t\t}\n\t\tc++;\n\t}\n\treturn 0;\n}\n\nvoid\ninit(SqCyQueueP q)\n{\n\tq->front = q->rear = 0;\n}\n\nint\nisEmpty(SqCyQueueP q)\n{\n\treturn q->front == q->rear;\n}\n\nint\nisFull(SqCyQueueP q)\n{\n\treturn (q->rear + 1) % M == q->front;\n}\n\nint\npush(SqCyQueueP q, ElemType item)\n{\n\tif (isFull(q)) {\n\t\treturn 0;\n\t}\n\n\tq->data[q->rear] = item;\n\tq->rear = (q->rear + 1) % M;\n\n\treturn 1;\n}\n\nint\npop(SqCyQueueP q, ElemType *item)\n{\n\tif (isEmpty(q)) {\n\t\treturn 0;\n\t}\n\n\t*item = q->data[q->front];\n\tq->front = (q->front + 1) % M;\n\n\treturn 1;\n}\n\nint\ngetFront(SqCyQueueP q, ElemType *item)\n{\n\tif (isEmpty(q)) {\n\t\treturn 0;\n\t}\n\t*item = q->data[q->rear];\n\treturn 1;\n}\n\nint\ngetSize(SqCyQueueP q)\n{\n\treturn (M + q->rear - q->front) % M;\n}\n", "problem_type": "PROGRAMMING", "title": "银行业务队列简单模拟"}, "1854547412460302360": {"problem_set_problem_id": "1854547412460302360", "compiler": "GCC", "program_content": "#include <stdio.h>\n\n#define M (305)\n\ntypedef int ElemType;\n\ntypedef struct {\n\tElemType data[M];\n\tint front, rear;\n} SqCyQueue, *SqCyQueueP;\n\nvoid init(SqCyQueueP);\nint isEmpty(SqCyQueueP);\nint isFull(SqCyQueueP);\nint push(SqCyQueueP, ElemType);\nint pop(SqCyQueueP, ElemType *);\nint popIndex(SqCyQueueP, int, ElemType *);\nint getFront(SqCyQueueP, ElemType *);\nint getSize(SqCyQueueP);\n\nint\nmain()\n{\n\tint n, k, m, idx = 0;\n\tSqCyQueue queue, queue_out;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n == 0 && m == 0)\n\t\t\tbreak;\n\t\tinit(&queue);\n\t\tinit(&queue_out);\n\t\tqueue.front = queue.rear = 0;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tpush(&queue, i);\n\t\t}\n\t\tElemType item;\n\t\tidx = queue.front;\t// 初始化第一个k开始报到m的人的位置\n\t\twhile (!isEmpty(&queue)) {\n\t\t\tif (queue.rear == 0)\n\t\t\t\tqueue.rear = M;\t// 队列尾指针到队列首时置为队列尾\n\t\t\tidx = (idx + (m - 1) % getSize(&queue)) % M;\t// 报数人位置加m - 1\n\t\t\tif (queue.rear <= idx || queue.rear == M)\n\t\t\t\tidx = (queue.front + (idx - queue.rear) % getSize(&queue)) % M;\t// 报到m人位置溢出时校正偏移\n\n\t\t\titem = queue.data[idx];\n\t\t\tfor (int i = idx, last_i; i != queue.rear - 1;) {\n\t\t\t\tlast_i = i;\n\t\t\t\ti = (i + 1) % M;\n\t\t\t\tqueue.data[last_i] = queue.data[i];\n\t\t\t}\n\t\t\tqueue.rear--;\n\t\t\tpush(&queue_out, item);\t// 将报到m的人编号推入输出队列\n\t\t}\n\t\tidx = queue_out.front;\n\t\twhile (!isEmpty(&queue_out)) {\t//\n\t\t\tpop(&queue_out, &item);\t//  输出输出队列\n\t\t}\n\t\tprintf(\"%d\\n\", item);\n\t}\n\treturn 0;\n}\n\nvoid\ninit(SqCyQueueP q)\n{\n\tq->front = q->rear = 0;\n}\n\nint\nisEmpty(SqCyQueueP q)\n{\n\treturn q->front == q->rear;\n}\n\nint\nisFull(SqCyQueueP q)\n{\n\treturn (q->rear + 1) % M == q->front;\n}\n\nint\npush(SqCyQueueP q, ElemType item)\n{\n\tif (isFull(q)) {\n\t\tprintf(\"队列已满，入队失败！\\n\");\n\t\treturn 0;\n\t}\n\n\tq->data[q->rear] = item;\n\tq->rear = (q->rear + 1) % M;\n\n\treturn 1;\n}\n\nint\npop(SqCyQueueP q, ElemType *item)\n{\n\tif (isEmpty(q)) {\n\t\tprintf(\"队列已空，出队失败！\\n\");\n\t\treturn 0;\n\t}\n\n\t*item = q->data[q->front];\n\tq->front = (q->front + 1) % M;\n\n\treturn 1;\n}\n\nint\ngetFront(SqCyQueueP q, ElemType *item)\n{\n\tif (isEmpty(q)) {\n\t\tprintf(\"队列已空！\\n\");\n\t\treturn 0;\n\t}\n\t*item = q->data[q->rear];\n\treturn 1;\n}\n\nint\ngetSize(SqCyQueueP q)\n{\n\treturn (M + q->rear - q->front) % M;\n}\n", "problem_type": "PROGRAMMING", "title": "h0181. 约瑟夫问题"}}}